pROGRAM TESTprogram;

{*
procedure p(var p1:array["string"] of string,p2:string);
begin
// <statement>
// <simple-statement>
// <assignment-statement>
// <variable> ":=" <expr>
var a,b,c:integer;
var x:array[5] of integer;
x[3]:=4;
read := "rea boi";
writeln (x[x.size-1].size);
x[2] := "yolo"

end;

procedure f ();
begin
read (a, b, c);
end;
*}
{*procedure p2(var a : integer, b : string, var c : integer);
begin end;*}

{*
procedure p(var p1: string, p2: integer);
begin
var p1 : integer;
read := "4";
var testpROGRAM : string;
p1 := -6;
while p2 < 4 do
    begin
        writeln("moi");
        return;
    end
end;

function d(p1: string, p2: integer) : string;
begin
var p2 : integer;
writeln ("moi");
while p2 < 4 do
begin
    if p2 = 4 then
        begin
        writeln ("p2 = 4");
        // return 4;
        end
    else
        begin
        var p1 : string;
        writeln ("p2 != 4");
        if p2 = 2 then
            begin
            writeln("moi");
            return 1;
            end
            else
            begin
            writeln("joo");
            return 2;
            end;
        end;
end;
writeln("joo");
end;
*}

begin 
var s : array[4] of string;
s[0] := "Moro vaan";
s[1] := "Toka";
s[2] := "Kolmas";
s[3] := "Vika";
var b : array[0] of string;
b := s;
s[2] := "Uuutta paskaa";
writeln(s.size+b.size);
writeln(s[0]);
writeln(s[1]);
writeln(s[2]);
writeln(s[3]);
writeln(b[0]);
writeln(b[1]);
writeln(b[2]);
writeln(b[3]);
var a : array[10] of integer;
a[0] := 1;
a[1] := 2;
a[2] := 0;
a[5] := 25;
a[7] := 9;
a[2] := a[0]+a[1]; 
writeln("a[2+3]: ", a[2+3]);
writeln("a[1]: ", a[1]);
writeln("a[2]: ", a[2]);
{*var a : integer;
a := 5;
var b : integer;
b := 4;
var t : array[a] of integer;
var y : array[b] of integer;
t[0] := 2;
t[1] := 3;
t[2] := 4;
t[3] := 5;
t[4] := 6;
y[0] := 7;
y[1] := 8;
y[2] := 9;
y[3] := 10;
var l : array[2] of integer;
l := t + y;
writeln("l[0]= ", l[0]);
writeln("l[1]= ", l[1]);
writeln("l[2]= ", l[2]);
writeln("l[3]= ", l[3]);
writeln("l[4]= ", l[4]);
writeln("l[5]= ", l[5]);
writeln("l[6]= ", l[6]);
writeln("l[7]= ", l[7]);
writeln("l[8]= ", l[8]);
writeln("The size of array l: ", l.size);
var c : string;
c := "ok " + "mo".size;
c := (-2+5) + c;
writeln("The size of string: ", c.size);
writeln("Size of closed expression array: ", (t+y).size);
writeln("Size of closed expression string: ", ("jees"+"box").size);
writeln(c);
writeln("Ok, please work: ", "the array l printed: " + l);
var paska : array[3] of integer;
paska[0] := 0;
paska[1] := 0;
paska[2] := 0;
paska[1] := 1000;
writeln(paska);*}
{*
// t[5] := 7;
y := t;
writeln("should be 3: ", y[1]);
writeln("should be 3 aswell: ", t[1]);
t[1] := 5;
writeln("should be 5: ", t[1]);
writeln("should remain 3: ", y[1]);
var ok : string;
ok := "string" + (-3-5+3) + "string";
ok := -4+"joo";
writeln("Should be string2string: ", ok);
var a : integer;
var b : integer;
var c : string;
c := "This is temp";
writeln("Should print: This is temp and in C-code should print s1 ", c);
a := 1 + 1;
a := a + 1;
writeln("a= ", a);
c := "Hello ";
var i : array[a] of integer;
i[1] := 2;
a := i[1]+1;
writeln("a= ", a);
writeln("i[1] = ", i[1]);
var d : array[5] of integer;
d[a] := 4;
var e : array[4] of integer;
e[1] := -a;
writeln("e[1] = ", e[1]);
writeln("a = ", a);
d[a] := -e[1];
writeln("d[a] = ", d[a]);
writeln(c, a, d[a]); // 2
c := "e[1] = ";
writeln(c, e[1]); // 2
e[1] := 4;
writeln("jeps: ", d[3]); // 2
writeln();
writeln(e[1]); // 4
//var e : integer; // this ties i3 back to e
//e := 2;
*}
{*
Should create:
int i0;
int i1;
int i2;
int i3 = 2;
int* i4 = malloc(i3*sizeof(i3)); // frees i3
i3 = 2;
*}
//b := 1;
//c := 2;
//a := b + c;
//writeln(a);

{*
#include <stdio.h>
#include <string.h>
//#inlude <math.h> // log10
int main() {
char* a;
int b;
a=malloc(strlen("Hello world! ")+1);
strcpy(a,"Hello world! ");
b=3+4;
// Now I know b is converted into a string. So: (Done in Expression level)
// snprintf(a, strlen(a)+1+(log10(b) + 1), "%s%d", a, b)
a=malloc(strlen(a+b)+1);
strcpy(a,a+b);
printf(a);
printf("%d",b);
printf("\n");
return 0;
}
*}

{*var a, b, c : string;
var a, e : integer;
var r : Boolean;
read (a, r, p, i);
var d : array[3 * 2] of string;
var p : integer;
writeln(p(a, 2));
return "vittu";*}
end .

{*
TEST CASES:

"program" <id> ";" <procedure> <main-block> "."
--> "program" <id> ";" "procedure" <id> "(" parameters ")" ";" <block> ";" <main-block> "."

"program" <id> ";" <function> <main-block> "."
--> "program" <id> ";" "function" <id> "(" parameters ")" ":" <type> ";" <block> ";" <main-block> "."
*}

{*
<program> ::= "program" <id> ";" { <procedure> | <function> } <main-block> "."
<procedure> ::= "procedure" <id> "(" parameters ")" ";" <block> ";"
<function> ::= "function" <id> "(" parameters ")" ":" <type> ";" <block> ";"
<var-declaration> ::= "var" <id> { "," <id> } ":" <type>
<parameters> ::= [ "var" ] <id> ":" <type> { "," [ "var" ] <id> ":" <type> } | <empty>
<type> ::= <simple type> | <array type>
<array type> ::= "array" "[" [<integer expr>] "]" "of" <simple type>
<simple type> ::= <type id>
<block> ::= "begin" <statement> { ";" <statement> } [ ";" ] "end"
<statement> ::= <simple statement> | <structured statement> | <var-declaration>
<empty> ::=

<simple statement> ::= <assignment statement> | <call> | <return statement> |
      < read statement> | <write statement> | <assert statement>
<assignment statement> ::= <variable> ":=" <expr>
<call> ::= <id> "(" <arguments> ")"
<arguments> ::= expr { "," expr } | <empty>
<return statement> ::= "return" [ expr ]
<read statement> ::= "read" "(" <variable> { "," <variable> } ")"
<write statement> ::= "writeln" "(" <arguments> ")"
<assert statement> ::= "assert" "(" <Boolean expr> ")"

<structured statement> ::= <block> | <if statement> | <while statement>
<if statement> ::= "if" <Boolean expr> "then" <statement> |
                "if" <Boolean expr> "then" <statement> "else" <statement>
<while statement> ::= "while" <Boolean expr> "do" <statement>

<expr> ::= <simple expr> |
    <simple expr> <relational operator> <simple expr>
<simple expr> ::= [ <sign> ] <term> { <adding operator> <term> }
<term> ::= <factor> { <multiplying operator> <factor> }
<factor> ::= <call> | <variable> | <literal> | "(" <expr> ")" | "not" <factor> | < factor> "." "size"
<variable> ::= <variable id> [ "[" <integer expr> "]" ] 

<relational operator> ::= "=" | "<>" | "<" | "<=" | ">=" | ">"
<sign> ::= "+" | "-"
<negation> ::= "not"
<adding operator> ::= "+" | "-" | "or"
<multiplying operator> ::= "*" | "/" | "%" | "and"

<id> ::= <letter> { <letter> | <digit> | "_" }
<literal> ::= <integer literal> | <real literal> | <string literal>
<integer literal> ::= <digits>
<digits> ::= <digit> { <digit> }
<real literal> ::= <digits> "." <digits> [ "e" [ <sign> ] <digits>]
<string literal> ::= "\"" { < a char or escape char > } "\""
<letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o |
    p | q | r | s | t | u | v | w | x | y | z | A | B | C |
    D | E | F | G | H | I | J | K | L | M | N | O | P
    | Q | R | S | T | U | V | W | X | Y | Z
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<special symbol or keyword> ::= "+" | "-" | "*" | "%" | "=" | "<>" | "<" | ">" | "<=" | ">=" |
    "(" | ")" | "[" | "]" | ":=" | "." | "," | ";" | ":" | "or" |
    "and" | "not" | "if" | "then" | "else" | "of" | "while" | "do" |
    "begin" | "end" | "var" | "array" | "procedure" |
    "function" | "program" | "assert" | "return"
<predefined id> ::= "Boolean" | "false" | "integer" | "read" | "real" | "size" |
    "string" | "true" | "writeln" 
*}

{*
First(<program>) = { "program" }

First(<procedure>) = { "procedure" }
Follow(<procedure>) = { "procedure", "function", "begin" }
Predict(<procedure>) = { }
*}
