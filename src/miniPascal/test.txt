pROGRAM TESTprogram;

{*
procedure p(var p1:array["string"] of string,p2:string);
begin
// <statement>
// <simple-statement>
// <assignment-statement>
// <variable> ":=" <expr>
var a,b,c:integer;
var x:array[5] of integer;
x[3]:=4;
read := "rea boi";
writeln (x[x.size-1].size);
x[2] := "yolo"

end;

procedure f ();
begin
read (a, b, c);
end;
*}
{*procedure p2(var a : integer, b : string, var c : integer);
begin end;*}

{*
procedure p(var p1: string, p2: integer);
begin
var p1 : integer;
read := "4";
var testpROGRAM : string;
p1 := -6;
while p2 < 4 do
    begin
        writeln("moi");
        return;
    end
end;

function d(p1: string, p2: integer) : string;
begin
var p2 : integer;
writeln ("moi");
while p2 < 4 do
begin
    if p2 = 4 then
        begin
        writeln ("p2 = 4");
        // return 4;
        end
    else
        begin
        var p1 : string;
        writeln ("p2 != 4");
        if p2 = 2 then
            begin
            writeln("moi");
            return 1;
            end
            else
            begin
            writeln("joo");
            return 2;
            end;
        end;
end;
writeln("joo");
end;
*}

begin 
var a : integer;
var b : integer;
var c : integer;
a := 3;
var d : array[5] of integer;
d[a] := 4;
var e : array[4] of integer;
e[1] := 2;
d[a] := e[1];
writeln(d[a]); // 2
writeln(e[1]); // 2
e[1] := 4;
writeln(d[3]); // 2
writeln(e[1]); // 4
//var e : integer; // this ties i3 back to e
//e := 2;
{*
Should create:
int i0;
int i1;
int i2;
int i3 = 2;
int* i4 = malloc(i3*sizeof(i3)); // frees i3
i3 = 2;
*}
//b := 1;
//c := 2;
//a := b + c;
//writeln(a);

{*
#include <stdio.h>
#include <string.h>
//#inlude <math.h> // log10
int main() {
char* a;
int b;
a=malloc(strlen("Hello world! ")+1);
strcpy(a,"Hello world! ");
b=3+4;
// Now I know b is converted into a string. So: (Done in Expression level)
// snprintf(a, strlen(a)+1+(log10(b) + 1), "%s%d", a, b)
a=malloc(strlen(a+b)+1);
strcpy(a,a+b);
printf(a);
printf("%d",b);
printf("\n");
return 0;
}
*}

{*var a, b, c : string;
var a, e : integer;
var r : Boolean;
read (a, r, p, i);
var d : array[3 * 2] of string;
var p : integer;
writeln(p(a, 2));
return "vittu";*}
end .

{*
TEST CASES:

"program" <id> ";" <procedure> <main-block> "."
--> "program" <id> ";" "procedure" <id> "(" parameters ")" ";" <block> ";" <main-block> "."

"program" <id> ";" <function> <main-block> "."
--> "program" <id> ";" "function" <id> "(" parameters ")" ":" <type> ";" <block> ";" <main-block> "."
*}

{*
<program> ::= "program" <id> ";" { <procedure> | <function> } <main-block> "."
<procedure> ::= "procedure" <id> "(" parameters ")" ";" <block> ";"
<function> ::= "function" <id> "(" parameters ")" ":" <type> ";" <block> ";"
<var-declaration> ::= "var" <id> { "," <id> } ":" <type>
<parameters> ::= [ "var" ] <id> ":" <type> { "," [ "var" ] <id> ":" <type> } | <empty>
<type> ::= <simple type> | <array type>
<array type> ::= "array" "[" [<integer expr>] "]" "of" <simple type>
<simple type> ::= <type id>
<block> ::= "begin" <statement> { ";" <statement> } [ ";" ] "end"
<statement> ::= <simple statement> | <structured statement> | <var-declaration>
<empty> ::=

<simple statement> ::= <assignment statement> | <call> | <return statement> |
      < read statement> | <write statement> | <assert statement>
<assignment statement> ::= <variable> ":=" <expr>
<call> ::= <id> "(" <arguments> ")"
<arguments> ::= expr { "," expr } | <empty>
<return statement> ::= "return" [ expr ]
<read statement> ::= "read" "(" <variable> { "," <variable> } ")"
<write statement> ::= "writeln" "(" <arguments> ")"
<assert statement> ::= "assert" "(" <Boolean expr> ")"

<structured statement> ::= <block> | <if statement> | <while statement>
<if statement> ::= "if" <Boolean expr> "then" <statement> |
                "if" <Boolean expr> "then" <statement> "else" <statement>
<while statement> ::= "while" <Boolean expr> "do" <statement>

<expr> ::= <simple expr> |
    <simple expr> <relational operator> <simple expr>
<simple expr> ::= [ <sign> ] <term> { <adding operator> <term> }
<term> ::= <factor> { <multiplying operator> <factor> }
<factor> ::= <call> | <variable> | <literal> | "(" <expr> ")" | "not" <factor> | < factor> "." "size"
<variable> ::= <variable id> [ "[" <integer expr> "]" ] 

<relational operator> ::= "=" | "<>" | "<" | "<=" | ">=" | ">"
<sign> ::= "+" | "-"
<negation> ::= "not"
<adding operator> ::= "+" | "-" | "or"
<multiplying operator> ::= "*" | "/" | "%" | "and"

<id> ::= <letter> { <letter> | <digit> | "_" }
<literal> ::= <integer literal> | <real literal> | <string literal>
<integer literal> ::= <digits>
<digits> ::= <digit> { <digit> }
<real literal> ::= <digits> "." <digits> [ "e" [ <sign> ] <digits>]
<string literal> ::= "\"" { < a char or escape char > } "\""
<letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o |
    p | q | r | s | t | u | v | w | x | y | z | A | B | C |
    D | E | F | G | H | I | J | K | L | M | N | O | P
    | Q | R | S | T | U | V | W | X | Y | Z
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<special symbol or keyword> ::= "+" | "-" | "*" | "%" | "=" | "<>" | "<" | ">" | "<=" | ">=" |
    "(" | ")" | "[" | "]" | ":=" | "." | "," | ";" | ":" | "or" |
    "and" | "not" | "if" | "then" | "else" | "of" | "while" | "do" |
    "begin" | "end" | "var" | "array" | "procedure" |
    "function" | "program" | "assert" | "return"
<predefined id> ::= "Boolean" | "false" | "integer" | "read" | "real" | "size" |
    "string" | "true" | "writeln" 
*}

{*
First(<program>) = { "program" }

First(<procedure>) = { "procedure" }
Follow(<procedure>) = { "procedure", "function", "begin" }
Predict(<procedure>) = { }
*}
